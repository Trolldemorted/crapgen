use std::{fs, path::Path, process::Command};

use regex::Regex;

use crate::ExportedFunction;

pub fn generate(input_path: &str, output_path: &Path) {
    let exports = parse_exports(input_path);
    let def_file_content = build_def_file(&exports);
    let exports_rs_file_content = build_exports_rs_file(&exports);

    let mut def_file_path = output_path.to_path_buf();
    def_file_path.push("src");
    def_file_path.push("ffi");
    fs::create_dir_all(&def_file_path).unwrap();
    def_file_path.push("deffile.def");
    fs::write(def_file_path, &def_file_content).unwrap();

    let mut exports_file_path = output_path.to_path_buf();
    exports_file_path.push("src");
    exports_file_path.push("ffi");
    exports_file_path.push("exports.rs");
    fs::write(exports_file_path, &exports_rs_file_content).unwrap();
}

fn parse_exports(path: &str) -> Vec<ExportedFunction> {
    let header_regex = Regex::new(r"^\s+ordinal\s+hint\s+RVA\s+name$").unwrap();
    let function_regex = Regex::new(
        r"^\s+(?<ordinal>\d+)\s+(?<hint>[0-9a-fA-F]+)\s+(?<rva>[0-9a-fA-F]+)\s+(?<name>.*)",
    )
    .unwrap();
    let dumpbin_exports_output = Command::new("dumpbin.exe")
        .arg("/exports")
        .arg(path)
        .output()
        .unwrap();
    let dumpbin_exports_str = str::from_utf8(&dumpbin_exports_output.stdout).unwrap();

    let mut exports = vec![];
    let mut parsing_functions = false;
    for line in dumpbin_exports_str.split("\r\n") {
        if line.is_empty() {
            continue;
        }

        if !parsing_functions && header_regex.is_match(line) {
            parsing_functions = true;
            continue;
        }

        if parsing_functions {
            if let Some(exported_function_match) = function_regex.captures(line) {
                let ordinal = exported_function_match.name("ordinal").unwrap().as_str();
                let name = exported_function_match.name("name").unwrap().as_str();
                exports.push(ExportedFunction {
                    ordinal: str::parse(ordinal).unwrap(),
                    name: name.to_string(),
                });
            } else {
                parsing_functions = false
            }
        }
    }

    exports
}

fn build_def_file(functions: &[ExportedFunction]) -> String {
    let mut output = "EXPORTS\n".to_string();

    for function in functions {
        output.push_str(&format!("    {} @{}\n", function.name, function.ordinal));
    }
    output
}

fn build_exports_rs_file(functions: &[ExportedFunction]) -> String {
    let mut output = "/// Generated by crapgen
use std::ffi::c_void;
use windows::{
    Win32::System::LibraryLoader::{GetProcAddress, LoadLibraryW},
    core::{PCWSTR, s},
};



pub unsafe fn load_original(original_dll_name: PCWSTR) {
    unsafe {
        let orig_hmodule = LoadLibraryW(original_dll_name).unwrap();
"
    .to_string();
    for function in functions {
        output.push_str(&format!(
            "
        ORDINAL{}_ORIGINAL_ADDRESS = GetProcAddress(orig_hmodule, s!(\"{}\")).unwrap() as _;",
            function.ordinal, function.name
        ));
    }

    output.push_str(
        "
    }
}

",
    );

    for function in functions {
        output.push_str(&format!(
            "pub static mut ORDINAL{}_ORIGINAL_ADDRESS: *mut c_void = 0 as _;\n",
            function.ordinal
        ));
    }

    for function in functions {
        output.push_str(&format!(
            "
#[unsafe(export_name = \"{}\")]
#[unsafe(naked)]
pub extern \"C\" fn ordinal_{}() {{
    core::arch::naked_asm!(\"jmp [rip+{{target}}]\", target = sym ORDINAL{}_ORIGINAL_ADDRESS);
}}
",
            function.name, function.ordinal, function.ordinal
        ));
    }
    output
}
